<!--
 * @Author: zaiying fan zaiying.fan@realai.ai
 * @Date: 2022-05-24 14:13:45
 * @LastEditors: zaiying fan zaiying.fan@realai.ai
 * @LastEditTime: 2022-05-25 17:27:00
 * @FilePath: \workspace\leetCode\算法4\6.0.2-BTree.html
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
</body>
<script>
  // 6.0.2 B-树
  // 在本小节中，我们将介绍一种3.3节的平衡树算法的扩展。它支持对保存在磁盘或者网络上的符号表进行外部查找，这些文件可能比我们以前考虑的输入要大的多（以前的输入能够保存在内存中）
  // 令人惊讶的是，我们将要学习的算法只需使用4～5个指向一小块数据的引用即可有效支持在含有数百亿或者更多元素的符号表中进行查找和插入操作。

  // B-树的成本模型。我们使用页的访问次数（无论读写）作为外部查找算法的成本模型。
  // 6.0.2.2 B-树
  // 它是对3.3节所述的2-3树数据结构的扩展。关键的不同在于：我们不会将数据保存在树中，而是会构造一棵由键的副本组成的树，每个副本都关联着一条链接
  // 和2-3树一样，我们限制了每个结点中能够含有的“键——链接”对的上下数量界限：选择一个参数M（一般都是一个偶数）并构造一棵多向树，每个结点最多含有M-1对键和链接（假设M足够小，使得每个M向结点都能够存放在一个页中），最少含有M/2对键和链接（以提供足够多的分支来保证查找路径较短）。
  // 根结点是个例外，它可以含有少于M/2对键和链接，但也不能少于2对。这种树被Bayer和McCreight在1970年命名为B-树

  // 在一棵4阶B-树中，每个结点都含有至少2对至多3对键-链接；在一棵6阶B-树中（请见图6.0.8），每个结点都至少含有3对至多5对键-链接（根结点除外，它可以只含有2对键与链接）

  // 6.0.2.3 约定
  // 为了说明基本的流程，我们先讨论（有序）（集合）SET的一个实现（只有键没有值）
  // 我们的目标是为一个巨大的键集实现add()和contains()方法。使用有序集的原因是我们希望将查找树推广，而这依赖于键的有序性。扩展实现来支持其他有序性操作也是十分有益的练习
  // 外部查找的应用常常会将索引和数据隔离。对于B-树，我们通过使用以下两种不同类型的结点做到这一点。❏内部结点：含有与页相关联的键的副本。❏外部结点：含有指向实际数据的引用。
  // ❏内部结点：含有与页相关联的键的副本。
  // ❏外部结点：含有指向实际数据的引用。

  // 内部结点中的每个键都与一个结点相关联，以此结点为根的子树中，所有的键都大于等于与此结点关联的键。但小于原内部结点中更大的键（如果存在的话）
  // !!!为了方便这里使用了一个特殊的哨兵键，它小于其他所有键
  // 一开始B-树只含有一个根节点，而根结点在初始化时仅含有该哨兵键。符号表不含有重复键，但我们会（在内部结点中）使用键的多个副本来引导查找。（在示例中，所有键都是单个字母并使用小于所有字母的“*”作为哨兵键。）
  
  // 6.0.2.4 查找和插入
  // B-树中查找的基础是在可能含有被查找键的唯一子树中进行递归搜索。当且仅当被查找的键包含在集合中时，每次查找便会结束于一个外部结点
  // 如果不在，则查找未命中。和2-3树一样，要在树的底部插入一个新键，可以使用递归代码
  // 如果空间不足，那么可以允许被插入的结点暂时“溢出”（变成一个6-结点），并在递归调用后向上不断分裂6-结点。如果根结点也变成了6-结点，则可以将它分裂成连接了两个3-结点的2-结点
  // 对于树的其他位置，我们将6-结点的父k-结点变为连接着两个3-结点的（k+1）-结点。将上文中的3替换成M/2,6替换成M，即可得到M阶B-树中的查找和插入操作的方法
  
  // 定义。一棵M阶B-树（M为正偶数）或者仅是一个外部k-结点（含有k个键和相关信息的树），或者由若干内部k-结点（每个结点都含有k个键和k条链接，链接指向的子树表示了键之间的间隔区域）组成。它的结构性质如下：从根结点到每个外部结点的路径长度均相同（完美平衡）；对于根结点，k在2到M-1之间，对于其他结点k在M/2到M-1之间。
  

  // 6.0.2.5 数据表示
  // 按照刚才的讨论，我们在选择B-树结点的表示方法上有很大的自由度。我们将这些选择封装在一个Page API中
  // 它可以关联键与指向Page对象的链接，支持检测页是否溢出、分裂页并区分内部页和外部页的操作
  // 你可以将Page看作一张符号表，但是是保存在外部介质上的（本地或是网络上的文件）
  // API中的术语“打开”（open）和“关闭”（close）指的是将外部页读入内存和将内存内容写回外部页（如果需要的话）的过程
  // 内部页的add()方法是一个符号表操作，会将给定页和以该页为根结点的子树中的最小键关联起来
  // 在所有实现中，最重要的方法都是split()。在分裂一张饱和页时，split()方法会将排序后位置正好大于M/2的键移动到一个新的Page对象中，并返回该对象的引用
  
  // 表6.0.2 B-树的页的API
  // public class Page<key>
  //              Page(boolean bottom)   创建并打开一个页
  //         void close()                关闭页
  //         void add(Key key)           将键插入（外部得）页中
  //         void add(Page p)            打开p，向这个（内部）页中插入一个条目并将p和p中得最小键相关联
  //      boolean isExternal()           这是一个外部页吗？
  //      boolean contains(Key key)      键key在页中吗
  //         Page next(Key key)          可能含有键key得子树
  //      boolean isFull()               页是否已经溢出
  //         Page split()                将较大得中间键移动到一个新页中

  // 在这些准备之后，后面框注“B-树集合的实现”的BTreeSET就很简单了。它用递归实现了contains()方法，接受一个Page对象作为参数并处理了以下3种情况。
  // ❏如果当前页是外部页且键在该页中，返回true。
  // ❏如果当前页是外部页且键不在该页中，返回false。
  // ❏否则，递归地在可能含有该键的子树中查找。
  // 我们用相同的递归结构实现了add()方法，只是在没有找到该键的时候将它插入到了树底部的页中，然后分裂回溯过程中所遇到的所有饱和结点

  // 6.0.2.6 性能
  // B-树最重要的性质就是，在实际应用中对于适当的参数M，查找的成本是常数级别的。
  // 命题B。含有N个元素的M阶B-树中的一次查找或插入操作需要logMN～logM/2N次探查——在实际情况下这基本是一个常数。

  // 证明。因为树中的所有内部结点（非根结点也非外部结点的所有结点）的形成都是由含有M个键的饱和结点分裂得到的且大小只可能增长（当它的子结点分裂时），所以其中的链接数总是在M/2到M-1之间
  // 在一般情况下，我们可以将根结点保存在内存中，这样可以将探查次数减1。在磁盘和网络中进行查找时，应该在开始大量查找前显示地完成这一步。在带有缓存的虚拟内存中，应该将根结点放在最快的缓存中，因为它是访问最频繁的结点
  

  // 6.0.2.7 空间需求在实际应用中，我们对B-树使用的空间也很感兴趣。由页的构造可知，它们至少都是半满的。在最坏的情况下，B-树所需的空间是所有键占用的实际空间的两倍再加上链接所需的空间
  // 算法6.1 B-树集合的实现
  class BTreeSET {
    constructor() {
      // 根节点
      this.root = new Page(true);
    }

    // contains方法
    contains(key) {
      return this.$$contains(this.root, key);
    }

    $$contains(h, key) {
      // isExternal() 这是一个外部页吗？
      if (h.isExternal()) {
        // 如果是个外部页
        // contains(Key key) 键key在页中吗
        return h.contains(key);
      }
      // next(Key key) 可能含有键key得子树
      // 递归调用子树
      return this.$$contains(h.next(key), key);
    }

    // add方法
    add(key) {
      // 递归调用
      this.$$add(this.root, key);
      // isFull() 页是否已经溢出，分裂为两个，并组建为一个新的root
      if (this.root.isFull()) {
        // 左半边
        var lefthalf = this.root;
        // 右半边
        // split() 将较大得中间键移动到一个新页中
        var righthalf = this.root.split();
        this.root = new Page(false);
        this.root.add(lefthalf);
        this.root.add(righthalf);
      }
    }

    $$add(h, key) {
      // isExternal() 这是一个外部页吗？
      if (h.isExternal()) {
        // 如果是个外部页
        // add(Key key) 将键插入（外部得）页中
        h.add(key);
        return;
      }
      // 如果不是外部页，查看可能含有key得子树
      // next(Key key) 可能含有键key得子树
      var next = h.next(key);
      // 递归子树查找
      this.$$add(next, key);
      // isFull() 页是否已经溢出
      // 如果溢出了，则将Next分裂，并将分裂出来的 较大的键 移动到一个新页面中，并在h中插入该键
      if (next.isFull()) {
        h.add(next.split());
      }
    }
  }
</script>
</html>